<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BUK - Open World Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            overflow: hidden;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 10px;
            pointer-events: all;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 8px;
            transition: width 0.3s ease;
        }
        
        .minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        .quest-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            border: 2px solid #4a90e2;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .story-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,40,0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            text-align: center;
            border: 3px solid #4a90e2;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: all;
        }
        
        .story-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: #4a90e2;
        }
        
        .story-text {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .continue-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .continue-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }
        
        .inventory {
            position: absolute;
            top: 50px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            opacity: 0.7;
        }
        
        .damage-indicator {
            position: absolute;
            color: #ff4444;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: damage-float 1s ease-out forwards;
        }
        
        @keyframes damage-float {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }
        
        .loading-title {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #4a90e2, #67b3ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .loading-bar {
            width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #67b3ff);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #4a90e2;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 3s infinite;
        }
        
        @keyframes particle-float {
            0%, 100% { opacity: 0; transform: translateY(0) rotate(0deg); }
            50% { opacity: 1; transform: translateY(-100px) rotate(180deg); }
        }
        
        .enemy-health {
            position: absolute;
            width: 60px;
            height: 8px;
            background: rgba(0,0,0,0.7);
            border: 1px solid white;
            border-radius: 4px;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .enemy-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 3px;
            transition: width 0.2s ease;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loadingScreen" class="loading-screen">
            <div class="loading-title">BUK</div>
            <div class="loading-bar">
                <div class="loading-fill" id="loadingFill"></div>
            </div>
            <div>Loading the mystical world...</div>
        </div>
        
        <div id="ui">
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%"></div>
            </div>
            
            <div class="minimap" id="minimap"></div>
            
            <div class="inventory" id="inventory">
                <div>‚öîÔ∏è Ancient Sword</div>
                <div>üõ°Ô∏è Leather Armor</div>
                <div>üß™ Health Potions: <span id="potionCount">3</span></div>
            </div>
            
            <div class="quest-log" id="questLog">
                <div style="color: #4a90e2; font-weight: bold;">Current Quest:</div>
                <div id="currentQuest">Explore the Ancient Ruins and discover the lost artifact.</div>
            </div>
            
            <div class="controls">
                <strong>Controls:</strong><br>
                WASD - Move<br>
                Mouse - Look around<br>
                Click - Attack<br>
                E - Interact<br>
                Space - Jump<br>
                P - Use Potion
            </div>
            
            <div class="crosshair"></div>
        </div>
        
        <div id="storyModal" class="story-modal" style="display: none;">
            <div class="story-title" id="storyTitle">Welcome to BUK</div>
            <div class="story-text" id="storyText">
                In a world where ancient magic and forgotten technologies intertwine, 
                you are the last Guardian of the Crystal Realm. The Shadow Legion has 
                awakened, threatening to consume all light from the world. Your quest 
                begins in the mystical Forest of Echoes...
            </div>
            <button class="continue-btn" onclick="closeStoryModal()">Begin Adventure</button>
        </div>
    </div>

    <script>
        class BUKGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.enemies = [];
                this.objects = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.gameState = {
                    health: 100,
                    potions: 3,
                    level: 1,
                    experience: 0,
                    currentQuest: "Explore the Ancient Ruins and discover the lost artifact."
                };
                this.questSteps = [
                    "Explore the Ancient Ruins and discover the lost artifact.",
                    "Defeat the Shadow Guardians protecting the temple.",
                    "Solve the ancient puzzle to unlock the sacred chamber.",
                    "Retrieve the Crystal of Eternal Light.",
                    "Return to the village and speak with the Elder."
                ];
                this.currentQuestIndex = 0;
                this.isLoading = true;
                this.loadingProgress = 0;
                
                this.init();
            }
            
            async init() {
                await this.showLoadingScreen();
                this.setupScene();
                this.createWorld();
                this.createPlayer();
                this.createEnemies();
                this.setupControls();
                this.setupUI();
                this.animate();
                this.showStoryModal();
            }
            
            async showLoadingScreen() {
                const loadingFill = document.getElementById('loadingFill');
                
                for (let i = 0; i <= 100; i += 2) {
                    loadingFill.style.width = i + '%';
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                document.getElementById('loadingScreen').style.display = 'none';
                this.isLoading = false;
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.camera.position.set(0, 10, 20);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB);
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                this.scene.add(directionalLight);
                
                // Atmospheric effects
                const pointLight = new THREE.PointLight(0xff6644, 0.5, 100);
                pointLight.position.set(0, 20, 0);
                this.scene.add(pointLight);
            }
            
            createWorld() {
                // Terrain
                const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
                const terrainMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x3a5f3a,
                    wireframe: false 
                });
                
                // Add height variation to terrain
                const vertices = terrainGeometry.attributes.position.array;
                for (let i = 2; i < vertices.length; i += 3) {
                    vertices[i] = Math.sin(vertices[i-2] * 0.01) * Math.cos(vertices[i-1] * 0.01) * 5;
                }
                terrainGeometry.computeVertexNormals();
                
                const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                this.scene.add(terrain);
                
                // Trees
                for (let i = 0; i < 200; i++) {
                    this.createTree(
                        (Math.random() - 0.5) * 800,
                        (Math.random() - 0.5) * 800
                    );
                }
                
                // Rocks and ruins
                for (let i = 0; i < 50; i++) {
                    this.createRock(
                        (Math.random() - 0.5) * 600,
                        (Math.random() - 0.5) * 600
                    );
                }
                
                // Ancient temple structure
                this.createTemple(0, -100);
                
                // Crystals
                for (let i = 0; i < 20; i++) {
                    this.createCrystal(
                        (Math.random() - 0.5) * 400,
                        (Math.random() - 0.5) * 400
                    );
                }
            }
            
            createTree(x, z) {
                const group = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(1, 2, 8, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a2a });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 4;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Leaves
                const leavesGeometry = new THREE.SphereGeometry(6, 8, 6);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5d2d });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 10;
                leaves.castShadow = true;
                group.add(leaves);
                
                group.position.set(x, 0, z);
                this.scene.add(group);
                this.objects.push(group);
            }
            
            createRock(x, z) {
                const geometry = new THREE.SphereGeometry(
                    Math.random() * 3 + 2,
                    6 + Math.floor(Math.random() * 4),
                    4 + Math.floor(Math.random() * 4)
                );
                const material = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const rock = new THREE.Mesh(geometry, material);
                rock.position.set(x, Math.random() * 2 + 1, z);
                rock.castShadow = true;
                rock.receiveShadow = true;
                this.scene.add(rock);
                this.objects.push(rock);
            }
            
            createTemple(x, z) {
                const group = new THREE.Group();
                
                // Base platform
                const baseGeometry = new THREE.BoxGeometry(40, 2, 40);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x8a7a6a });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 1;
                base.receiveShadow = true;
                group.add(base);
                
                // Pillars
                for (let i = 0; i < 4; i++) {
                    const pillarGeometry = new THREE.CylinderGeometry(2, 2, 15);
                    const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                    const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    
                    const angle = (i / 4) * Math.PI * 2;
                    pillar.position.set(Math.cos(angle) * 15, 9.5, Math.sin(angle) * 15);
                    pillar.castShadow = true;
                    group.add(pillar);
                }
                
                // Central altar
                const altarGeometry = new THREE.BoxGeometry(6, 4, 6);
                const altarMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const altar = new THREE.Mesh(altarGeometry, altarMaterial);
                altar.position.y = 4;
                altar.castShadow = true;
                group.add(altar);
                
                group.position.set(x, 0, z);
                this.scene.add(group);
                this.objects.push(group);
            }
            
            createCrystal(x, z) {
                const geometry = new THREE.OctahedronGeometry(2, 0);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x4a90e2,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x1a3a5a
                });
                const crystal = new THREE.Mesh(geometry, material);
                crystal.position.set(x, 2, z);
                crystal.rotation.y = Math.random() * Math.PI;
                crystal.castShadow = true;
                crystal.userData = { type: 'crystal', collected: false };
                this.scene.add(crystal);
                this.objects.push(crystal);
            }
            
            createPlayer() {
                const geometry = new THREE.BoxGeometry(1, 2, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0x0066cc });
                this.player = new THREE.Mesh(geometry, material);
                this.player.position.set(0, 1, 20);
                this.player.castShadow = true;
                
                // Weapon
                const weaponGeometry = new THREE.BoxGeometry(0.2, 3, 0.2);
                const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(1.2, 0.5, 0);
                this.player.add(weapon);
                
                this.scene.add(this.player);
                
                // Camera follows player
                this.camera.position.copy(this.player.position);
                this.camera.position.y += 5;
                this.camera.position.z += 10;
                this.camera.lookAt(this.player.position);
            }
            
            createEnemies() {
                for (let i = 0; i < 15; i++) {
                    const enemy = this.createEnemy(
                        (Math.random() - 0.5) * 500,
                        (Math.random() - 0.5) * 500
                    );
                    this.enemies.push(enemy);
                }
            }
            
            createEnemy(x, z) {
                const group = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(1.2, 1.8, 1.2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x660000 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.9;
                body.castShadow = true;
                group.add(body);
                
                // Eyes (glowing effect)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x440000
                });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.3, 1.2, 0.5);
                group.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.3, 1.2, 0.5);
                group.add(rightEye);
                
                group.position.set(x, 0, z);
                group.userData = { 
                    health: 50,
                    maxHealth: 50,
                    lastAttack: 0,
                    target: null,
                    state: 'idle',
                    speed: 0.02
                };
                
                this.scene.add(group);
                return group;
            }
            
            setupControls() {
                // Keyboard controls
                window.addEventListener('keydown', (event) => {
                    this.keys[event.code] = true;
                    
                    if (event.code === 'KeyP') {
                        this.usePotion();
                    }
                });
                
                window.addEventListener('keyup', (event) => {
                    this.keys[event.code] = false;
                });
                
                // Mouse controls
                window.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                });
                
                window.addEventListener('click', () => {
                    this.attack();
                });
                
                // Prevent context menu
                window.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupUI() {
                this.updateHealthBar();
                this.updateQuestLog();
                this.updateInventory();
                this.createParticles();
            }
            
            updateHealthBar() {
                const healthFill = document.getElementById('healthFill');
                const healthPercent = (this.gameState.health / 100) * 100;
                healthFill.style.width = healthPercent + '%';
                
                if (healthPercent < 30) {
                    healthFill.style.background = 'linear-gradient(90deg, #ff0000, #ff4444)';
                } else {
                    healthFill.style.background = 'linear-gradient(90deg, #ff4444, #ff6666)';
                }
            }
            
            updateQuestLog() {
                const questLog = document.getElementById('currentQuest');
                questLog.textContent = this.questSteps[this.currentQuestIndex];
            }
            
            updateInventory() {
                const potionCount = document.getElementById('potionCount');
                potionCount.textContent = this.gameState.potions;
            }
            
            createParticles() {
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'particle';
                        particle.style.left = Math.random() * window.innerWidth + 'px';
                        particle.style.top = window.innerHeight + 'px';
                        particle.style.animationDelay = Math.random() * 3 + 's';
                        document.body.appendChild(particle);
                        
                        setTimeout(() => {
                            particle.remove();
                        }, 3000);
                    }, i * 100);
                }
            }
            
            handleMovement() {
                if (this.isLoading) return;
                
                const moveSpeed = 0.3;
                const direction = new THREE.Vector3();
                
                if (this.keys['KeyW']) direction.z -= 1;
                if (this.keys['KeyS']) direction.z += 1;
                if (this.keys['KeyA']) direction.x -= 1;
                if (this.keys['KeyD']) direction.x += 1;
                
                if (direction.length() > 0) {
                    direction.normalize();
                    this.player.position.add(direction.multiplyScalar(moveSpeed));
                    
                    // Update camera to follow player
                    this.camera.position.copy(this.player.position);
                    this.camera.position.y += 5;
                    this.camera.position.z += 10;
                    this.camera.lookAt(this.player.position);
                    
                    // Check for quest progression
                    this.checkQuestProgress();
                }
                
                if (this.keys['Space']) {
                    this.player.position.y = Math.max(this.player.position.y + 0.2, 1);
                    setTimeout(() => {
                        if (this.player.position.y > 1) {
                            this.player.position.y -= 0.2;
                        }
                    }, 200);
                }
            }
            
            updateEnemies() {
                this.enemies.forEach((enemy, index) => {
                    if (!enemy.userData) return;
                    
                    const playerDistance = enemy.position.distanceTo(this.player.position);
                    
                    if (playerDistance < 30) {
                        // Chase player
                        const direction = new THREE.Vector3()
                            .subVectors(this.player.position, enemy.position)
                            .normalize();
                        
                        enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
                        enemy.lookAt(this.player.position);
                        enemy.userData.state = 'chasing';
                        
                        // Attack if close enough
                        if (playerDistance < 3 && Date.now() - enemy.userData.lastAttack > 1000) {
                            this.enemyAttack(enemy);
                            enemy.userData.lastAttack = Date.now();
                        }
                    } else {
                        enemy.userData.state = 'idle';
                        // Random movement when idle
                        if (Math.random() < 0.01) {
                            const randomDirection = new THREE.Vector3(
                                (Math.random() - 0.5) * 0.1,
                                0,
                                (Math.random() - 0.5) * 0.1
                            );
                            enemy.position.add(randomDirection);
                        }
                    }
                    
                    // Rotate enemies slowly
                    enemy.rotation.y += 0.01;
                    
                    // Remove dead enemies
                    if (enemy.userData.health <= 0) {
                        this.scene.remove(enemy);
                        this.enemies.splice(index, 1);
                        this.gainExperience(25);
                    }
                });
            }
            
            attack() {
                const attackRange = 5;
                
                this.enemies.forEach(enemy => {
                    const distance = this.player.position.distanceTo(enemy.position);
                    
                    if (distance < attackRange) {
                        const damage = Math.floor(Math.random() * 20) + 15;
                        enemy.userData.health -= damage;
                        
                        // Visual feedback
                        this.showDamage(enemy.position, damage);
                        
                        // Knockback effect
                        const knockbackDirection = new THREE.Vector3()
                            .subVectors(enemy.position, this.player.position)
                            .normalize();
                        enemy.position.add(knockbackDirection.multiplyScalar(2));
                        
                        // Flash effect
                        const originalColor = enemy.children[0].material.color.getHex();
                        enemy.children[0].material.color.setHex(0xffffff);
                        setTimeout(() => {
                            enemy.children[0].material.color.setHex(originalColor);
                        }, 100);
                    }
                });
            }
            
            enemyAttack(enemy) {
                const damage = Math.floor(Math.random() * 15) + 5;
                this.gameState.health = Math.max(0, this.gameState.health - damage);
                this.updateHealthBar();
                
                // Visual feedback
                this.showDamage(this.player.position, damage);
                this.screenShake();
                
                // Game over check
                if (this.gameState.health <= 0) {
                    this.gameOver();
                }
            }
            
            showDamage(position, damage) {
                const damageElement = document.createElement('div');
                damageElement.className = 'damage-indicator';
                damageElement.textContent = `-${damage}`;
                damageElement.style.left = (Math.random() * 100) + '%';
                damageElement.style.top = (Math.random() * 100) + '%';
                document.getElementById('ui').appendChild(damageElement);
                
                setTimeout(() => {
                    damageElement.remove();
                }, 1000);
            }
            
            screenShake() {
                const camera = this.camera;
                const originalPosition = camera.position.clone();
                
                const shakeIntensity = 0.5;
                const shakeDuration = 300;
                const startTime = Date.now();
                
                const shake = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed < shakeDuration) {
                        camera.position.x = originalPosition.x + (Math.random() - 0.5) * shakeIntensity;
                        camera.position.y = originalPosition.y + (Math.random() - 0.5) * shakeIntensity;
                        camera.position.z = originalPosition.z + (Math.random() - 0.5) * shakeIntensity;
                        requestAnimationFrame(shake);
                    } else {
                        camera.position.copy(originalPosition);
                    }
                };
                shake();
            }
            
            usePotion() {
                if (this.gameState.potions > 0 && this.gameState.health < 100) {
                    this.gameState.potions--;
                    this.gameState.health = Math.min(100, this.gameState.health + 50);
                    this.updateHealthBar();
                    this.updateInventory();
                    
                    // Visual effect
                    const healEffect = document.createElement('div');
                    healEffect.style.position = 'absolute';
                    healEffect.style.top = '50%';
                    healEffect.style.left = '50%';
                    healEffect.style.transform = 'translate(-50%, -50%)';
                    healEffect.style.color = '#00ff00';
                    healEffect.style.fontSize = '24px';
                    healEffect.style.fontWeight = 'bold';
                    healEffect.style.pointerEvents = 'none';
                    healEffect.style.animation = 'damage-float 1s ease-out forwards';
                    healEffect.textContent = '+50 HP';
                    document.getElementById('ui').appendChild(healEffect);
                    
                    setTimeout(() => {
                        healEffect.remove();
                    }, 1000);
                }
            }
            
            gainExperience(amount) {
                this.gameState.experience += amount;
                
                // Level up check
                const expNeeded = this.gameState.level * 100;
                if (this.gameState.experience >= expNeeded) {
                    this.levelUp();
                }
            }
            
            levelUp() {
                this.gameState.level++;
                this.gameState.experience = 0;
                this.gameState.health = 100; // Full heal on level up
                this.updateHealthBar();
                
                // Level up notification
                const levelUpEffect = document.createElement('div');
                levelUpEffect.style.position = 'absolute';
                levelUpEffect.style.top = '30%';
                levelUpEffect.style.left = '50%';
                levelUpEffect.style.transform = 'translate(-50%, -50%)';
                levelUpEffect.style.color = '#ffdd00';
                levelUpEffect.style.fontSize = '36px';
                levelUpEffect.style.fontWeight = 'bold';
                levelUpEffect.style.pointerEvents = 'none';
                levelUpEffect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.7)';
                levelUpEffect.style.animation = 'damage-float 2s ease-out forwards';
                levelUpEffect.textContent = `LEVEL UP! Level ${this.gameState.level}`;
                document.getElementById('ui').appendChild(levelUpEffect);
                
                setTimeout(() => {
                    levelUpEffect.remove();
                }, 2000);
            }
            
            checkQuestProgress() {
                // Check proximity to temple for quest progression
                const templeDistance = this.player.position.distanceTo(new THREE.Vector3(0, 0, -100));
                
                if (templeDistance < 20 && this.currentQuestIndex === 0) {
                    this.currentQuestIndex = 1;
                    this.updateQuestLog();
                    this.showQuestUpdate("You've discovered the Ancient Temple!");
                }
                
                // Check if all enemies in area are defeated
                const nearbyEnemies = this.enemies.filter(enemy => 
                    enemy.position.distanceTo(this.player.position) < 30
                );
                
                if (nearbyEnemies.length === 0 && this.currentQuestIndex === 1) {
                    this.currentQuestIndex = 2;
                    this.updateQuestLog();
                    this.showQuestUpdate("Area cleared! The temple awaits...");
                }
                
                // Collect crystals for quest progression
                this.objects.forEach(obj => {
                    if (obj.userData && obj.userData.type === 'crystal' && !obj.userData.collected) {
                        const distance = this.player.position.distanceTo(obj.position);
                        if (distance < 3) {
                            obj.userData.collected = true;
                            obj.visible = false;
                            this.showQuestUpdate("Crystal collected! Ancient power flows through you.");
                            
                            if (this.currentQuestIndex === 2) {
                                this.currentQuestIndex = 3;
                                this.updateQuestLog();
                            }
                        }
                    }
                });
            }
            
            showQuestUpdate(message) {
                const questUpdate = document.createElement('div');
                questUpdate.style.position = 'absolute';
                questUpdate.style.top = '20%';
                questUpdate.style.left = '50%';
                questUpdate.style.transform = 'translate(-50%, -50%)';
                questUpdate.style.background = 'rgba(74, 144, 226, 0.9)';
                questUpdate.style.color = 'white';
                questUpdate.style.padding = '15px 25px';
                questUpdate.style.borderRadius = '10px';
                questUpdate.style.fontSize = '18px';
                questUpdate.style.fontWeight = 'bold';
                questUpdate.style.textAlign = 'center';
                questUpdate.style.pointerEvents = 'none';
                questUpdate.style.border = '2px solid #ffffff';
                questUpdate.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
                questUpdate.style.animation = 'damage-float 3s ease-out forwards';
                questUpdate.textContent = message;
                document.getElementById('ui').appendChild(questUpdate);
                
                setTimeout(() => {
                    questUpdate.remove();
                }, 3000);
            }
            
            gameOver() {
                const gameOverScreen = document.createElement('div');
                gameOverScreen.style.position = 'absolute';
                gameOverScreen.style.top = '0';
                gameOverScreen.style.left = '0';
                gameOverScreen.style.width = '100%';
                gameOverScreen.style.height = '100%';
                gameOverScreen.style.background = 'rgba(0,0,0,0.8)';
                gameOverScreen.style.display = 'flex';
                gameOverScreen.style.flexDirection = 'column';
                gameOverScreen.style.justifyContent = 'center';
                gameOverScreen.style.alignItems = 'center';
                gameOverScreen.style.color = 'white';
                gameOverScreen.style.fontSize = '48px';
                gameOverScreen.style.zIndex = '1000';
                gameOverScreen.innerHTML = `
                    <div style="margin-bottom: 20px;">GAME OVER</div>
                    <div style="font-size: 18px; margin-bottom: 30px;">The Shadow Legion has consumed the realm...</div>
                    <button onclick="location.reload()" style="
                        background: linear-gradient(135deg, #4a90e2, #357abd);
                        border: none;
                        color: white;
                        padding: 15px 30px;
                        border-radius: 10px;
                        cursor: pointer;
                        font-size: 18px;
                        transition: all 0.3s ease;
                    ">Restart Adventure</button>
                `;
                document.getElementById('ui').appendChild(gameOverScreen);
            }
            
            updateAnimations() {
                // Animate crystals
                this.objects.forEach(obj => {
                    if (obj.userData && obj.userData.type === 'crystal') {
                        obj.rotation.y += 0.02;
                        obj.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.5;
                    }
                });
                
                // Animate environmental effects
                this.scene.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        const intensity = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
                        child.material.emissive.setScalar(intensity);
                    }
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.isLoading) {
                    this.handleMovement();
                    this.updateEnemies();
                    this.updateAnimations();
                    
                    // Auto-regenerate health slowly
                    if (this.gameState.health < 100 && Date.now() % 5000 < 16) {
                        this.gameState.health = Math.min(100, this.gameState.health + 1);
                        this.updateHealthBar();
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            showStoryModal() {
                document.getElementById('storyModal').style.display = 'block';
            }
        }
        
        // Initialize the game
        let game;
        
        function closeStoryModal() {
            document.getElementById('storyModal').style.display = 'none';
            
            // Show next story segment
            setTimeout(() => {
                const storyModal = document.getElementById('storyModal');
                const storyTitle = document.getElementById('storyTitle');
                const storyText = document.getElementById('storyText');
                
                storyTitle.textContent = "Your Quest Begins";
                storyText.innerHTML = `
                    The ancient prophecy speaks of a chosen Guardian who will restore balance to the realm. 
                    Armed with the legendary sword of your ancestors, you must venture forth into the mystical 
                    Forest of Echoes.<br><br>
                    
                    <strong>Beware:</strong> The Shadow Legion's minions patrol these lands, and only by growing 
                    stronger through combat and exploration can you hope to reach the Sacred Temple and claim 
                    the Crystal of Eternal Light.
                `;
                
                storyModal.style.display = 'block';
                
                // Auto-close after showing tutorial
                setTimeout(() => {
                    storyModal.style.display = 'none';
                }, 5000);
            }, 1000);
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            game = new BUKGame();
        });
        
        // Additional game utilities
        function createMagicEffect(position, color = 0x4a90e2) {
            const particles = [];
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 5
                ));
                
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.2
                );
                
                game.scene.add(particle);
                particles.push(particle);
            }
            
            // Animate particles
            const animateParticles = () => {
                particles.forEach((particle, index) => {
                    particle.position.add(particle.velocity);
                    particle.material.opacity -= 0.02;
                    
                    if (particle.material.opacity <= 0) {
                        game.scene.remove(particle);
                        particles.splice(index, 1);
                    }
                });
                
                if (particles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            };
            
            animateParticles();
        }
        
        // Weather system
        function createWeatherEffect() {
            // Rain particles
            const rainGeo = new THREE.BufferGeometry();
            const rainCount = 1000;
            const posArray = new Float32Array(rainCount * 3);
            
            for (let i = 0; i < rainCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 1000;
            }
            
            rainGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            const rain = new THREE.Points(rainGeo, rainMaterial);
            game.scene.add(rain);
            
            // Animate rain
            function animateRain() {
                const positions = rain.geometry.attributes.position.array;
                
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= Math.random() * 2;
                    
                    if (positions[i] < -500) {
                        positions[i] = 500;
                    }
                }
                
                rain.geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateRain);
            }
            
            if (Math.random() < 0.3) { // 30% chance of rain
                animateRain();
            }
        }
        
        // Sound system (placeholder for future audio integration)
        const SoundManager = {
            sounds: {
                attack: 'üó°Ô∏è',
                damage: 'üí•',
                heal: '‚ú®',
                levelUp: '‚≠ê',
                questComplete: 'üéä'
            },
            
            play(soundName) {
                // Visual sound feedback since we can't play actual sounds
                const soundIndicator = document.createElement('div');
                soundIndicator.style.position = 'fixed';
                soundIndicator.style.top = '10px';
                soundIndicator.style.right = '200px';
                soundIndicator.style.fontSize = '24px';
                soundIndicator.style.pointerEvents = 'none';
                soundIndicator.style.animation = 'damage-float 0.5s ease-out forwards';
                soundIndicator.textContent = this.sounds[soundName] || 'üîä';
                document.body.appendChild(soundIndicator);
                
                setTimeout(() => {
                    soundIndicator.remove();
                }, 500);
            }
        };
    </script>
</body>
</html>
